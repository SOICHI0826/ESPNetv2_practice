# -*- coding: utf-8 -*-
"""utils.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yChiyDyLikvhWMxbIYUh0qV93dJ5glJL
"""

import os
import torch
import shutil
import torch.nn.functional as F
import time

class AverageMeter(object):
  def __init__(self):
    self.reset()
  def reset(self):
    self.val = 0
    self.avg = 0
    self.sum = 0
    self.count = 0
  def update(self, val, n = 1):
    self.val = val
    self.sum += val * n
    self.count += n
    self.avg = self.sum / self.count
  

def accuracy(output, target, topk = (1, )):
  maxk = max(topk)
  batch_size = target.size(0)

  _, pred = output.topk(maxk, 1, True, True)
  pred = pred.t()
  correct = pred.eq(target.view(1, -1).expand_as(pred))

  res = []
  for k in topk:
    correct_k = correct[:k].view(-1).float().sum(0, keepdim = True)
    res.append(correct_k.mul_(100.0 / batch_size))
  return res

def loss_fn(output, labels):
  return F.cross_entropy(outputs, labels)

def train(train_loader, model, optimizer, epoch):
  batch_time = AverageMeter()
  data_time = AverageMeter()
  losses = AverageMeter()
  top1 = AverageMeter()
  top5 = AverageMeter()

  model.train()

  end = time.time()

  for i, (input, target) in enumerate(train_loader):

    data_time.update(time.time() - end)

    input = input.cuda(non_blocking = True)
    target = target.cuda(non_blocking = True)

    output = model(input)

    loss = loss_fn(output, target)

    prec1, prec5 = accuracy(output, target, topk = (1, 5))
    losses.update(loss.item(), input.size(0))
    top1.update(prec1[0], input.size(0))
    top5.update(prec5[0], input.size(0))

    optimizer.zero_grad()
    loss.backward()
    optimizer.step()

    batch_time.update(time.time() - end)
    end = time.time()

    if i % 100 == 0:
      print("Epoch: %d[%d/%d]\t\tBatch Time:%.4f\t\tLoss:%.4f\t\ttop1:%.4f (%.4f)\t\ttop5:%.4f (%.4f)" %
            (epoch, i, len(train_loader), batch_time.avg, lossed.avg, top1.val, top1.avg, top5.val, top5.avg))
  return top1.avg, losses.avg

def validate(val_loader, model):
  batch_time = AverageMeter()
  losses = AverageMeter()
  top1 = AverageMeter()
  top5 = AverageMeter()

  model.eval()

  end = time.time()

  with torch.no_glad():
    for i, (input, target) in enumerate(val_loader):
      input = input.cuda(non_blocking = True)
      target = target.cuda(non_blocking = True)

      output = model(input)
      loss = loss_fn(output, target)

      prec1, prec5 = accuracy(output, target, topk = (1, 5))

      losses.update(loss.item(), input.size(0))
      top1.update(prec1[0], input.size(0))
      top5.update(prec5[0], input.size(0))

      batch_time.update(time.time() - end)
      end = time.time() 

      if i % 100 == 0:
        print("Batch:[%d/%d]\t\tBatchTime:%.3f\t\tLoss:%.3f\t\ttop1:%.3f (%.3f)\t\ttop5:%.3f(%.3f)"%
              (i, len(val_loader), batch_time.avg, losses.avg, top1.val, top1.avg, top5.val, top5.avg))
      
      print(' * Prec@1:%.3f Prec@5:%.3f' % (top1.avg, top5.avg))

      return top1.avg, losses.avg
